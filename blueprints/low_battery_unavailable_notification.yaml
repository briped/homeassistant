blueprint:
  name: Device/entity availability notification
  description: Regularly check all entities for low battery or unavailability.
    Device must be assigned to an area to be monitored. Areas with names beginning with underscore '_' will not be monitored.
    Monitored devices with a 'battery' device-class will be checked for battery level.

    Notify if
      'state.state' is 'on' (domain binary_sensor) or 'state.state' is less than battery_threshold (domain sensor).
      'state.state' is 'unavailable'.

  domain: automation

  source_url: https://raw.githubusercontent.com/briped/homeassistant/master/blueprints/low_battery_unavailable_notification.yaml

  input:
    battery_threshold:
      name: Battery warning level threshold
      description: Battery sensors below battery_threshold are assumed to be low-battery (as
        well as binary battery sensors with value 'on').
      default: 20
      selector:
        number:
          min: 5.0
          max: 100.0
          unit_of_measurement: '%'
          mode: slider
          step: 5.0
    time:
      name: Time to test on
      description: Test is run at configured time
      default: '10:00:00'
      selector:
        time: {}
    day:
      name: Weekday to test on
      description: 'Test is run at configured time either everyday (0) or on a given
        weekday (1: Monday ... 7: Sunday)'
      default: 0
      selector:
        number:
          min: 0.0
          max: 7.0
          mode: slider
          step: 1.0
    day_alt:
      name: Weekday to test on (alt)
      description: Check at the configured time, on the selected weekdays.
      default: {}
      selector:
        select:
          mode: dropdown
          multiple: true
          options:
            - Monday
            - Tuesday
            - Wednesday
            - Thursday
            - Friday
            - Saturday
            - Sunday
    exclude:
      name: Excluded Devices/Areas
      description: Devices and/or Areas to exclude from monitoring.
      default: {}
      selector:
        target:
          entity:
            device_class: battery
    actions:
      name: Actions
      description: Notifications or similar to be run. {{sensors}} is replaced with
        the names of sensors being low on battery.
      selector:
        action: {}
variables:
  day: !input 'day'
  battery_threshold: !input 'battery_threshold'
  exclude: !input 'exclude'
  sensors: >-
    {% set entities = namespace(data=[]) %}
    {% set devices = namespace(data=[]) %}

    {% set battery_threshold = namespace(variables=50) %}

    {# Loop through all entities with state == unavailable. #}
    {% for state in states 
      | selectattr('state', '==', 'unavailable') %}
      {# Add found entities to dictionary. #}
      {% set entities.data = entities.data + [{'entity_id': state.entity_id, 'device_id': device_id(state.entity_id), 'state': state.state}] %}
    {% endfor %}

    {# Loop through all binary_sensors with the 'battery' device_class. #}
    {% for state in states.binary_sensor
      | rejectattr('attributes.device_class', 'undefined') 
      | selectattr('attributes.device_class', 'eq', 'battery') 
      | selectattr('state', '==', 'on') %}
      {# Add found entities to dictionary. #}
      {% set entities.data = entities.data + [{'entity_id': state.entity_id, 'device_id': device_id(state.entity_id), 'state': state.state}] %}
    {% endfor %}

    {#
    {{entities.data | unique(attribute='device_id') | list}}
    #}

    {# Loop through all unique devices from the entities dictionary. #}
    {% for entity in entities.data 
      | unique(attribute='device_id') %}
      {% if area_name(state.entity_id) != None and area_name(state.entity_id)[0:1] != '_' %}
        {# Add devices to dictionary, if not excluded. TODO: Add area and device exclusion. #}
        {% set devices.data = devices.data + [{'device_id': entity.device_id, 'device_name': device_attr(entity.entity_id, 'name'), 'state': entity.state}] %}
      {% endif %}
    {% endfor %}

    {{devices.data}}

trigger:
- platform: time
  at: !input 'time'
condition:
- '{{ sensors != '''' and (day | int == 0 or day | int == now().isoweekday()) }}'
action:
- choose: []
  default: !input 'actions'
mode: single